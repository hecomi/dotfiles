names=read_nonblock
visibility=public
kind=defined

--- read_nonblock(maxlen, buf) -> String
通信路から maxlen  バイトを上限としてデータを読み込み、
文字列として返します。

即座に得られるデータが 1byte でも存在すればブロックしません。
内部バッファが空でない場合はバッファのデータを返します。
即座に得られるデータが存在しないときには例外が発生します。
例外が発生した場合、内部のソケットが利用可能になってから
再びこのメソッドを呼んでください。

基本的には [[m:IO#read_nonblock]] と同様です。しかし以下のような
違いもあります。

このメソッドはソケットが書き込み不可能([[c:IO::WaitWritable]])という理由で
例外を発生させる可能性があります。暗号プロトコルの関係上
データの読み込みになんらかのデータの送受信が必要になる場合があるからです。

内部のソケットが読み込み/書き込み可能である場合でも、このメソッドが
文字列を得られず、例外が発生する場合があります。
というのは、暗号プロトコルによっては(とくにブロック暗号では)
通信データをある程度の大きさのブロック単位で暗号化/復号化
するためです。



@param maxlen 読み込む長さの上限(整数)
@param buf 読み込みバッファ
@raise EOFError 読み込みが既に終端に到達している場合に発生します
@raise OpenSSL::SSL::SSLError ソケットが読み込み/書き込み可能状態になるのを
       待つ必要がある場合に発生します。
       読み込み可能状態を待つ必要がある場合には [[c:IO::WaitReadable]] を、
       書き込み可能状態を待つ必要がある場合には [[c:IO::WaitWritable]] を、
       それぞれ extend した例外オブジェクトが生成されます。

